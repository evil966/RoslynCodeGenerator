using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;

namespace SourceGenerator
{
    [Generator(LanguageNames.CSharp)]
    public sealed class SqlBundlerGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Pick up all .sql files
            var sqlFiles = context.AdditionalTextsProvider
                .Where(file => file.Path.EndsWith(".sql", StringComparison.OrdinalIgnoreCase));

            // Combine all into a single generation step
            var combined = sqlFiles.Collect();

            context.RegisterSourceOutput(combined, GenerateSource);
        }

        private void GenerateSource(SourceProductionContext context, ImmutableArray<AdditionalText> sqlFiles)
        {
            if (sqlFiles.IsDefaultOrEmpty)
                return;

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("namespace SqlScripts");
            sb.AppendLine("{");

            var root = new FolderNode("Root");

            foreach (var file in sqlFiles)
            {
                var text = file.GetText(context.CancellationToken)?.ToString() ?? string.Empty;
                var pathParts = GetPathParts(file.Path);

                FolderNode current = root;

                // Build folder structure
                for (int i = 0; i < pathParts.Count - 1; i++)
                {
                    current = current.GetOrAddChild(pathParts[i]);
                }

                var fileName = Path.GetFileNameWithoutExtension(pathParts.Last());
                current.Files[fileName] = text;
            }

            // Generate class code recursively
            foreach (var folder in root.Children.Values)
            {
                WriteFolderClass(sb, folder, 1);
            }

            sb.AppendLine("}");

            context.AddSource("SqlScripts.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static List<string> GetPathParts(string fullPath)
        {
            var relative = fullPath.Replace('\\', '/');
            var index = relative.IndexOf("/Sql/", StringComparison.OrdinalIgnoreCase);
            if (index >= 0)
                relative = relative.Substring(index + 5); // Skip "/Sql/"

            return relative.Split('/', (char)StringSplitOptions.RemoveEmptyEntries).ToList();
        }

        private static void WriteFolderClass(StringBuilder sb, FolderNode folder, int indent)
        {
            string indentStr = new string(' ', indent * 4);
            sb.AppendLine($"{indentStr}public static class {SanitizeIdentifier(folder.Name)}");
            sb.AppendLine($"{indentStr}{{");

            foreach (var kv in folder.Files)
            {
                string name = SanitizeIdentifier(kv.Key);
                string sql = kv.Value.Replace("\"", "\"\"");
                sb.AppendLine($"{indentStr}    public const string {name} = @\"{sql}\";");
            }

            foreach (var child in folder.Children.Values)
            {
                WriteFolderClass(sb, child, indent + 1);
            }

            sb.AppendLine($"{indentStr}}}");
        }

        private static string SanitizeIdentifier(string name)
        {
            var invalid = Path.GetInvalidFileNameChars()
                .Concat(new[] { '-', '.', ' ' })
                .ToArray();

            foreach (var ch in invalid)
                name = name.Replace(ch, '_');

            if (char.IsDigit(name.FirstOrDefault()))
                name = "_" + name;

            return name;
        }

        private class FolderNode
        {
            public string Name { get; }
            public Dictionary<string, FolderNode> Children { get; } = new();
            public Dictionary<string, string> Files { get; } = new();

            public FolderNode(string name) => Name = name;

            public FolderNode GetOrAddChild(string name)
            {
                name = SanitizeIdentifier(name);
                if (!Children.TryGetValue(name, out var child))
                {
                    child = new FolderNode(name);
                    Children[name] = child;
                }
                return child;
            }
        }
    }
}
